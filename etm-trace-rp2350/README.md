# etm-trace-rp2350
This setup is intended to facilitate running the [etm-trace-rp2350](https://github.com/czietz/etm-trace-rp2350)
repo.

Some related discussion can be found in this [forum post](https://forums.raspberrypi.com/viewtopic.php?t=383655).

## Requirements
* Raspberry Pi Pico 2 W
* Raspberry Pi Debug Probe
* Ubuntu machine 
* USB cables for Pico and Debug Probe
* 3-pin JST-SH cables (usually comes with the debug probe)

## Step 1. Flash Firmware for Pico 2 W
Follow the [pico 2w debugging setup](/pico-2w-debug).

## Step 2. Install OpenOCD on Ubuntu
Up to July 2025, the official openocd version 0.12.0 does not support rp2350 
configuration automatically. Since Pico 2 W features rp2350, download the latest
openocd from github and install it.

1. Install dependency (some might be redundant):
```
sudo apt install libtool libusb-1.0-0-dev libftdi1-dev autoconf automake texinfo pkg-config
```

2. Clone and build openocd
```
git clone --recurse-submodules https://github.com/raspberrypi/openocd.git --depth=1
cd openocd
./bootstrap
./configure --enable-ftdi --enable-internal-jimtcl
make -j$(nproc)
sudo make install
```

## Step 3. Connect Debug Probe 
Follow the [official doc](https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html#serial-connections) to 
1. Connect Raspberry Pi Debug Probe with Pico 2 W using 3-pin JST-SH cables
2. Connect Raspberry Pi Debug Probe to Ubuntu machine with an USB cable
3. Power Pico 2 W with an USB cable
An example:
![connection](connection.png)

## Step 4. GDB Connection with OpenOCD
Up to July 2025, openocd needs to be built from source in order to include the
support for rp2350 which is used by Pico 2 W. Make sure this is done in Step 2.

1. **Go to the openocd directory**, then run the command below. 
Note that the openocd command suggested by the [official doc](https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html#standalone-program-upload) looks slightly different, as it 
assumes the openocd is installed via the OS rather than built from source.
```
sudo src/openocd -s tcl -f interface/cmsis-dap.cfg -f target/rp2350.cfg -c "adapter speed 5000"
```

2. **Open another terminal**, locate the ```.elf``` file built in Step 1. In the 
example, this file is called ```blink.elf```, launch a gdb session targeting this
```.elf``` file. Note that the following command also performs a remote 
connection to the target program (by default openocd connects at port 3333).
```
gdb-multiarch <path-to-elf-file> -ex "target remote :3333"
```

Right after connection, the target (Pico 2 W) immediately pauses due to the 
design of openocd. GDB command ```monitor reset init``` can be used to release 
the halt (See next step). Note that running the command will not resume the execution until
```continue``` is passed.

## Step 5. Collect the Trace
The [trace.gdb](trace.gdb) file is the key to collect the ETM trace. Thanks to 
[@czietz](https://github.com/czietz) who open sourced this splendid debugging
script. The actual script locates at [here](https://github.com/czietz/etm-trace-rp2350/blob/master/trace.gdb), 
the one used by this documentation is simply its copy made for the commit 
```15a1e86```. (2025/07/15: The trace.gdb file used by this documentation has
been slightly modified to print more info about the ETM device.)

1. In the **GDB terminal**, load the tracing script with the following command 
(make sure the path to ```trace.gdb``` is correct!): 
```
(gdb) source trace.gdb
```

2. Release the halting point generated by openocd:
```
(gdb) monitor reset init
```

3. Type the following commands to collect the trace.
```
(gdb) trc_setup
(gdb) trc_start 1
(gdb) trc_save ~/trace.bin
```

## Step 6. Parse the Trace with ```ptm2human```
A tool named ```ptm2human``` can be used to analyze the trace data. [@czietz](https://github.com/czietz) 
provided a link to his fork of [ptm2human](https://github.com/czietz/ptm2human/), 
which works well with the trace collected for Cortex-M33.

1. Download and build the ```ptm2human``` tool:
```
git clone https://github.com/czietz/ptm2human.git
cd ptm2human
./autogen.sh
./configure
make
```

2. Use the ```ptm2human``` program to parse the collected trace data:
```
./ptm2human -e -n -i ~/trace.bin
```

A snippet of the parsed trace looks like the following:
```
Reading /home/erkaii/trace.bin
Syncing the trace stream...
Decoding the trace stream...
TraceInfo - Cycle count disabled,
            Tracing of conditional non-branch instruction disabled,
            No explicit tracing of load instructions,
            No explicit tracing of store instructions,
            p0_key = 0x0,
            curr_spec_depth = 0,
            cc_threshold = 0x0
ATOM - N
Commit - 1
Context - Context ID = 0x0,
          VMID = 0x0,
          Exception level = EL0,
          Security = S,
          32-bit instruction
Address - Instruction address 0x000000001000137c, Instruction set Aarch32 (ARM)
ATOM - N
Commit - 1
ATOM - E
Commit - 1
Address - Instruction address 0x0000000010001356, Instruction set Aarch32 (ARM)
ATOM - N
Commit - 1
ATOM - N
Commit - 1
ATOM - N
Commit - 1
ATOM - N
Commit - 1
ATOM - N
Commit - 1
ATOM - E
Commit - 1
```

## Next Step
See [Trace Analysis](trace_analysis.md). 

